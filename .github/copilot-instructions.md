# @plq/faker - TypeScript Mock Data Library

**ALWAYS follow these instructions first and only fallback to additional search or context gathering if the information here is incomplete or found to be in error.**

@plq/faker is a TypeScript library for generating mock data objects including users, domains, repositories, browser history, downloads, bookmarks, and project trackers. The library compiles to JavaScript and is published to npm as `@plq/faker`.

## Working Effectively

### Bootstrap and Build the Repository
Run these commands in exact order to set up the development environment:

1. **Install dependencies** (NEVER skip this step):
   ```bash
   npm ci
   ```
   - Takes approximately 4 seconds
   - Requires internet connection
   - CRITICAL: Build will fail without dependencies installed

2. **Lint the code**:
   ```bash
   npm run lint
   ```
   - Takes approximately 1 second
   - Uses ESLint with TypeScript rules defined in `eslint.config.mjs`
   - NEVER CANCEL: Always run before committing changes

3. **Run tests**:
   ```bash
   npm run test
   ```
   - Takes approximately 4 seconds
   - Uses Jest with TypeScript support
   - Runs all tests in `__tests__/` directory
   - Shows coverage report (target: 99%+ coverage)
   - NEVER CANCEL: Required before any code changes

4. **Build the library**:
   ```bash
   npm run build
   ```
   - Takes approximately 6 seconds
   - Compiles TypeScript to JavaScript in `lib/` directory
   - Generates declaration files (.d.ts) and source maps
   - NEVER CANCEL: Required for testing library functionality

### Full Development Workflow
Run the complete validation sequence:
```bash
npm ci && npm run lint && npm run test && npm run build
```
- Total time: approximately 15 seconds
- NEVER CANCEL: Wait for all commands to complete
- This matches the CI pipeline sequence

## Validation Scenarios

**ALWAYS test library functionality after making changes by running these validation scenarios:**

### Basic Functionality Test
Create and run this test to validate core functionality:
```javascript
const { User, Domain, Repository, Project, History, Downloads, Tracker, Bookmarks } = require('./lib/index.js');

// Test 1: Basic user generation
const user = new User().getItem();
console.log('User:', user); // Should have firstName, lastName, nickname, email, fullName

// Test 2: User with custom domain
const domain = new Domain().getItem();
const customUser = new User(domain).getItem();
console.log('Custom user email should use domain:', customUser.email, 'with domain:', domain.domainName);

// Test 3: Repository generation
const repo = new Repository().getItem();
console.log('Repository:', repo); // Should have provider, user, project, url, templates

// Test 4: History with parameters
const history = new History({ 
  text: 'github.com',
  maxResults: 5,
  startTime: new Date().getTime() - 1000 * 60 * 60 * 24 * 7
}).getItems();
console.log('History items:', history.length); // Should generate 5 items
```

### Package Structure Validation
Always verify the build output is correct:
```javascript
const pkg = require('./package.json');
const lib = require('./lib/index.js');
const exports = Object.keys(lib);
const expectedExports = ['Domain', 'History', 'Project', 'Repository', 'Tracker', 'User', 'Downloads', 'Bookmarks'];
console.log('Available exports:', exports);
// All expectedExports should be present in exports array
```

## Development Requirements

### Required Software
- **Node.js**: Version 18.18.0+ (specified version: 22.18.0 in `.node-version`)
- **npm**: Comes with Node.js
- Internet connection required for initial `npm ci`

### File Structure Understanding
- **`src/`**: TypeScript source files - ALL development happens here
- **`lib/`**: Compiled JavaScript output - NEVER edit directly, generated by build
- **`__tests__/`**: Jest test files - Add tests here when adding new features
- **`package.json`**: Dependencies and scripts configuration
- **`tsconfig.json`**: TypeScript compiler settings
- **`jest.config.ts`**: Test configuration
- **`eslint.config.mjs`**: Linting rules

### Key Classes and Usage Patterns
Always reference these patterns when working with the library:

1. **Base Pattern**: All mock classes extend `BaseItemMock<T, Q>`
   - `T`: The mock item type
   - `Q`: The query/configuration type

2. **User**: `new User(domain?).getItem()` - Generates user data
3. **Domain**: `new Domain().getItem()` - Generates domain information  
4. **Repository**: `new Repository(query?).getItem()` - Generates git repository data
5. **History**: `new History(query?).getItems()` - Generates browser history (note: getItems plural)
6. **Downloads**: `new Downloads(query?).getItem()` - Generates browser download data
7. **Project**: `new Project().getItem()` - Generates project/company data
8. **Tracker**: `new Tracker().getItem()` - Generates Jira/YouTrack data
9. **Bookmarks**: `new Bookmarks(query?).getItems()` - Generates browser bookmarks (note: getItems plural)

## CI Pipeline Requirements

The GitHub Actions CI (`.github/workflows/main.yml`) runs:
1. `npm ci` 
2. `npm run lint`
3. `npm run test` 
4. `npm run build`

**ALWAYS run these exact commands locally before committing to ensure CI will pass.**

## Common Issues and Solutions

### Build Failures
- **Problem**: `Cannot find module '@faker-js/faker'` errors
- **Solution**: Run `npm ci` first - dependencies are required

### Test Failures
- **Problem**: Tests fail after code changes
- **Solution**: Check if new code follows existing patterns in `src/` files

### Linting Failures  
- **Problem**: ESLint errors on commit
- **Solution**: Run `npm run lint` and fix all errors before committing

## Important Notes

- **NEVER edit files in `lib/` directory** - they are generated by the build process
- **ALWAYS run the full workflow** (install → lint → test → build) after making changes
- **Dependencies are required** - the project cannot build without `npm ci`
- **Test coverage should remain above 99%** - add tests for new functionality
- **All commands are fast** (under 10 seconds each) - no need for long timeouts

## Release Process

The project uses `release-it` for automated releases:
- **Release command**: `npm run release` (requires `.env` file with release credentials)
- **Pre-release validation**: Automatically runs `npm run lint`, `npm test`, `npm run build`
- **Versioning**: Uses conventional commits for automated version bumping
- **Changelog**: Auto-generated in `CHANGELOG.md`

## Quick Reference Commands

```bash
# Complete setup and validation (run after any changes):
npm ci && npm run lint && npm run test && npm run build

# Individual commands:
npm ci   # Install dependencies (~4 seconds)
npm run lint              # Check code style (~1 second)  
npm run test              # Run test suite (~4 seconds)
npm run build             # Compile TypeScript (~6 seconds)

# Test library functionality:
node -e "const {User} = require('./lib'); console.log(new User().getItem())"
```

Always execute the complete workflow and validation scenarios to ensure your changes work correctly and will pass CI.